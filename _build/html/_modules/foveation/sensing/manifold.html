

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>foveation.sensing.manifold &mdash; foveation 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            foveation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../read_me.html">A biologically-inspired foveated interface for deep vision models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart.html">Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Core Components</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.sensing.html">foveation.sensing package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.arch.html">foveation.arch package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.saccadenet.html">foveation.saccadenet</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.trainer.html">foveation.trainer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Utilities &amp; Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.utils.html">foveation.utils package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.demo.html">foveation.demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.paths.html">foveation.paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.probes.html">foveation.probes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/foveation.visualizer.html">foveation.visualizer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">foveation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../../foveation.html">foveation</a></li>
      <li class="breadcrumb-item active">foveation.sensing.manifold</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for foveation.sensing.manifold</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">cumulative_trapezoid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">root_scalar</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">trimesh</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">add_to_all</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="CorticalSensorManifold">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold">[docs]</a>
<span class="nd">@add_to_all</span><span class="p">(</span><span class="n">__all__</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CorticalSensorManifold</span><span class="p">():</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    3-D cortical sensor manifold based on Rovamu and Virsu (1984) (see also Motter (2009)).</span>
<span class="sd">    Relevant coordinate systems:</span>

<span class="sd">    * :math:`(x, y)` -&gt; visual cartesian coordinates</span>
<span class="sd">    * :math:`(r, \theta)` -&gt; visual polar coordinates</span>
<span class="sd">    * :math:`(\rho, z, \phi)` -&gt; cortical cylindrical coordinates</span>
<span class="sd">    * :math:`(x_c, y_c, z)` -&gt; cortical cartesian coordinates</span>

<span class="sd">    We use the magnification function: :math:`M(r)=\frac{k}{r+a}`, where:</span>

<span class="sd">    * :math:`k`: scaling factor that gives a good match to cortical mm. irrelevant for foveated sampling.</span>
<span class="sd">    * :math:`a`: critical parameter controlling magnification. smaller == stronger magnification / foveation</span>

<span class="sd">    Due to our choice of magnification function, this is essentially a 3d extension of the complex logarithmic map (Schwartz, 1980), where both preserve local isotropy unlike the Schwartz (1980) model, our 3D version also preserves global/meridional isotropy, since there is no warping due to flattening</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CorticalSensorManifold.__init__">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            cmf_a (float): a parameter in cortical magnification function (CMF), in degrees</span>
<span class="sd">            fov (float): visual field size in degrees</span>
<span class="sd">            k (float): scaling factor that gives a good match to cortical mm. irrelevant for foveated sampling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmf_a</span> <span class="o">=</span> <span class="n">cmf_a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fov</span> <span class="o">=</span> <span class="n">fov</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

        <span class="c1"># compute cortical radius (z) over a fine mesh of the visual field by integration of the CMF</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="mf">0.0001</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">fov</span><span class="p">,</span> <span class="n">spacing</span><span class="p">)</span> <span class="c1"># we go out well beyond r=fov/2 to support padding</span>
        <span class="n">z_integrand_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_integrand</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> 
        <span class="n">integral_vals</span> <span class="o">=</span> <span class="n">cumulative_trapezoid</span><span class="p">(</span><span class="n">z_integrand_vec</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Integral from 0 to each x_grid point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_integral_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">integral_vals</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.m">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.m">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cortical magnification as a function of eccentricity r</span>

<span class="sd">        Args:</span>
<span class="sd">            r (float): visual radius</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: cortical magnification in mm/deg, evaluated at r</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cmf_a</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="c1"># mm/deg</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.rho_3d">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.rho_3d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rho_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute cortical radius in 3d cylindrical coordinates: :math:`m(r)*\sin(r)`</span>

<span class="sd">        Counterintuitively from the equation, the units are mm rather than mm/rad:</span>

<span class="sd">        *   this is because there is a left over radian term from the derivation</span>
<span class="sd">        *   :math:`r=m(r)*\sin(r)*d\theta/d\phi`. While :math:`d\theta` and :math:`d\phi` cancel out, :math:`d\theta` is in radians while :math:`d\phi` is unitless. </span>
<span class="sd">        *   :math:`d\phi` is unitless because it is part of an infinitesimal distance :math:`r*d\phi` along the cortical surface that is in units mm. r keeps the mm units and :math:`d\phi` is unitless. </span>
<span class="sd">        *   We use :math:`m(r)` in mm/deg: thus :math:`m(r)*\sin(r)` -&gt; mm*rad/deg, so we convert to mm by multiplying by 180 deg/pi rad.</span>

<span class="sd">        Args:</span>
<span class="sd">            r (float): visual radius</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: cortical radius in mm</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deg_per_rad</span> <span class="o">=</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">deg_per_rad</span> <span class="c1"># mm</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.phi_3d">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.phi_3d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phi_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cortical phi in 3d cylindrical coordinates. :math:`\phi=\theta`</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            theta (float): Visual polar angle (in radians).</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Cortical cylindrical coordinate :math:`\phi` (in radians).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">theta</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.dm_dr">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.dm_dr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dm_dr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        derivative of cortical magnification function with respect to radius (:math:`dm/dr`)</span>

<span class="sd">        Args:</span>
<span class="sd">            r (float): Visual radius in degrees</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: :math:`dm/dr` in mm/deg^2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">*</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">cmf_a</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.drho_dr">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.drho_dr">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">drho_dr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        derivative of cortical cylindrical radius with respect to visual field radius (:math:`d\rho/dr`)</span>

<span class="sd">        Args:</span>
<span class="sd">            r (float): Visual radius in degrees</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: :math:`d\rho/dr` in mm/deg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">deg_per_rad</span> <span class="o">=</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dm_dr</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="n">deg_per_rad</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">r</span><span class="p">))</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.z_integrand">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.z_integrand">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">z_integrand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        integrand for cortical z in 3d cylindrical coordinates: :math:`(m(r)^2 - (d\rho/dr)^2)^{0.5}`</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            r (float): Visual radius in degrees</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: :math:`(m(r)^2 - (d\rho/dr)^2)^{0.5}` in mm/deg</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drho_dr</span><span class="p">(</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.z_3d">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.z_3d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">z_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        cortical z in 3d cylindrical coordinates computed with numerical integration via interpolation of fine mesh of precomputed values</span>

<span class="sd">        Args:</span>
<span class="sd">            r (float): Visual radius in degrees</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: cortical z in mm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_integral_interp</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.map_3d">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.map_3d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        map cartesian :math:`(x,y)` coordinates to 3D cortical cylindrical coordinates :math:`(\rho,z,\phi)`</span>

<span class="sd">        Args:</span>
<span class="sd">            x (float): visual cartesian x coordinate</span>
<span class="sd">            y (float): visual cartesian y coordinate</span>
<span class="sd">        Returns:</span>
<span class="sd">            rho_z_phi (tuple[float, float, float]): 3D cortical cylindrical coordinates :math:`(\rho, z, \phi)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho_3d</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_3d</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rho</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.map_to_xyz">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.map_to_xyz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_to_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_z_phi</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        map 3d cortical cylindrical coordinates to cortical cartesian coordinates for plotting convenience</span>

<span class="sd">        Args:</span>
<span class="sd">            rho_z_phi (tuple): 3D cortical cylindrical coordinates</span>
<span class="sd">        Returns:</span>
<span class="sd">            result (tuple): A tuple containing:</span>
<span class="sd">                - x_c (float): cortical cartesian x coordinate</span>
<span class="sd">                - y_c (float): cortical cartesian y coordinate</span>
<span class="sd">                - z (float): cortical cartesian z coordinate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">rho_z_phi</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y_c</span> <span class="o">=</span> <span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_c</span><span class="p">,</span> <span class="n">y_c</span><span class="p">,</span> <span class="n">z</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.normalize_coords">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.normalize_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">normalize_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        normalize coordinates to lie between -1 and 1</span>

<span class="sd">        Args:</span>
<span class="sd">            coords (np.ndarray): un-normalized coordinates (n, d)</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: normalized coordinates (n, d) </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># normalize between -1 and 1</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">normalize</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.cort_cartesian_to_cort_cylindrical">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.cort_cartesian_to_cort_cylindrical">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cort_cartesian_to_cort_cylindrical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_y_z</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map cortical cartesian coordinates to cortical cylindrical coordinates for reverse mapping</span>

<span class="sd">        Args:</span>
<span class="sd">            x_y_z (tuple): cortical cartesian coordinates :math:`(x_c, y_c, z)`</span>
<span class="sd">        Returns:</span>
<span class="sd">            result (tuple): A tuple containing:</span>
<span class="sd">                - rho (float): r in cortical cylindrical coordinates</span>
<span class="sd">                - z (float): z in cortical cylindrical coordinates</span>
<span class="sd">                - phi (float): :math:`\phi` in cortical cylindrical coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x_y_z</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rho</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.vis_cartesian_to_cort_cartesian">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.vis_cartesian_to_cort_cartesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vis_cartesian_to_cort_cartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_y</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map visual cartesian coordinates to cortical cartesian coordinates</span>

<span class="sd">        Args:</span>
<span class="sd">            x_y (np.ndarray): visual cartesian coordinates :math:`(x,y)`</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: cortical cartesian coordinates :math:`(x_c, y_c, z)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_to_xyz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x_y</span><span class="p">])</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.r_from_z">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.r_from_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">r_from_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use a numerical root-finding method to determine eccentricity from the cortical z coordinate</span>

<span class="sd">        Args:</span>
<span class="sd">            z (float): cortical z coordinate in mm</span>
<span class="sd">        Returns:</span>
<span class="sd">            float: visual eccentricity (radius) in degrees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">root_scalar</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;brentq&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">root</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.cylindrical_to_visual_polar">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.cylindrical_to_visual_polar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cylindrical_to_visual_polar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rho_z_phi</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reverse map from cortical cylindrical coordinates to visual polar coordinates</span>

<span class="sd">        Args:</span>
<span class="sd">            rho_z_phi (tuple): tuple :math:`(\rho, z, \phi)` of cortical cylindrical coordinates</span>
<span class="sd">        Returns:</span>
<span class="sd">            result (tuple): A tuple containing:</span>
<span class="sd">                - r (float): visual eccentricity (radius) in degrees</span>
<span class="sd">                - phi (float): visual polar angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">rho_z_phi</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r_from_z</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.init_visual_mesh">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.init_visual_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_visual_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        initialize a grid of visual points to specify the bounds of the 3d mesh before sampling points on it</span>

<span class="sd">        Args:</span>
<span class="sd">            rs (np.ndarray, optional): array of r values to test.</span>
<span class="sd">        Returns:</span>
<span class="sd">            result (tuple): A tuple containing:</span>
<span class="sd">                - grid_pts_3d_xyz (np.ndarray): (n, 3) array of cortical cartesian coordinates</span>
<span class="sd">                - grid_pts_polar (np.ndarray): (n, 2) array of visual polar coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid_pts_polar</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">theta_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">)</span> <span class="k">if</span> <span class="n">rs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">rs</span>
        <span class="c1"># we go to self.fov/2+1 so that we can remove 1 deg worth of visual angle from closed surface mesh to open it back up later</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span><span class="mf">0.0001</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">500</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">grid_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>
                <span class="n">grid_pts_polar</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">theta</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">theta_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">100</span><span class="p">):</span>
                <span class="n">grid_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)))</span>
                <span class="n">grid_pts_polar</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>

        <span class="n">grid_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_pts</span><span class="p">)</span>
        <span class="n">grid_pts_polar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_pts_polar</span><span class="p">)</span>

        <span class="c1"># map the grid to 3D</span>
        <span class="n">grid_pts_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="bp">self</span><span class="o">.</span><span class="n">map_3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">grid_pts</span><span class="p">])</span>
        <span class="n">grid_pts_3d_xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">map_to_xyz</span><span class="p">(</span><span class="n">rho_z_phi</span><span class="p">)</span> <span class="k">for</span> <span class="n">rho_z_phi</span> <span class="ow">in</span> <span class="n">grid_pts_3d</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">grid_pts_3d_xyz</span><span class="p">,</span> <span class="n">grid_pts_polar</span></div>


<div class="viewcode-block" id="CorticalSensorManifold.init_cortical_mesh">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.init_cortical_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_cortical_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_pts_3d_xyz</span><span class="p">,</span> <span class="n">num_coords</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        initialize a 3d mesh of approximately evenly spaced cortical points</span>

<span class="sd">        NOTE:</span>

<span class="sd">        * this is not evenly-spaced enough to be useful, but we keep it around for reference</span>
<span class="sd">        * instead, we define the mesh by sampling visual radii according to the CMF, and performing locally isotropic sampling of angles. </span>
<span class="sd">        * this is equivalent to uniform sampling on the cortical sensor manifold</span>
<span class="sd">        * the sensor manifold is thus used primarily for receptive field sampling once the mesh has been defined</span>

<span class="sd">        Args:</span>
<span class="sd">            grid_pts_3d_xyz (np.ndarray): (n,3) array of cortical cartesian coordinates used as a starting point to determine bounds</span>
<span class="sd">            num_coords (int): number of coordinates to generate on the surface</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: (n,3) array of cortical cartesian coordinates that are approximately evenly spaced</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert grid_pts_3d_uniform to a mesh </span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">grid_pts_3d_xyz</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">grid_pts_3d_xyz</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>  
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">Trimesh</span><span class="p">(</span><span class="n">vertices</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">process</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Extract the outer surface of the mesh</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">convex_hull</span>  

        <span class="n">max_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fov</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Z threshold for 1 degree of visual angle</span>

        <span class="c1"># sample the surface evenly (even sampling in cortical space)</span>
        <span class="n">num_coords</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="mf">1.2</span>
        <span class="k">while</span> <span class="n">num_coords</span> <span class="o">&lt;</span> <span class="n">num_coords</span><span class="p">:</span>
            <span class="n">uniform_points_3d</span> <span class="o">=</span> <span class="n">trimesh</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">sample_surface_even</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mult</span><span class="o">*</span><span class="n">num_coords</span><span class="p">),</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Remove points corresponding to 1 degree worth of visual angle</span>
            <span class="n">uniform_points_3d</span> <span class="o">=</span> <span class="n">uniform_points_3d</span><span class="p">[</span><span class="n">uniform_points_3d</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_z</span><span class="p">]</span>

            <span class="n">num_coords</span> <span class="o">=</span> <span class="n">uniform_points_3d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mult</span> <span class="o">*=</span> <span class="mf">1.1</span>

        <span class="c1"># sort by z</span>
        <span class="n">uniform_points_3d</span> <span class="o">=</span> <span class="n">uniform_points_3d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">uniform_points_3d</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])]</span>

        <span class="c1"># # sample num_coords point randomly to get correct number</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># ensure reproducibility</span>
        <span class="n">uniform_points_3d</span> <span class="o">=</span> <span class="n">uniform_points_3d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">uniform_points_3d</span><span class="p">),</span> <span class="n">num_coords</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">uniform_points_3d</span>    </div>

    
<div class="viewcode-block" id="CorticalSensorManifold.reverse_map">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.CorticalSensorManifold.reverse_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reverse_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_points_xyz</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        reverse map from cortical cartesian coordinates to visual cartesian and polar coordinates</span>

<span class="sd">        Args:</span>
<span class="sd">            mesh_points_xyz (np.ndarray): (n,3) cortical cartesian mesh pts</span>
<span class="sd">        Returns:</span>
<span class="sd">            result (tuple): A tuple containing:</span>
<span class="sd">                - cartesian_visual (np.ndarray): (n, 2) visual cartesian mesh pts</span>
<span class="sd">                - polar_visual (np.ndarray): (n, 2) visual polar mesh pts</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get points in cylindrical coordinates to do reverse mapping</span>
        <span class="n">mesh_points_cylindrical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cort_cartesian_to_cort_cylindrical</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span> <span class="k">for</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="n">mesh_points_xyz</span><span class="p">])</span>
        <span class="c1"># reverse map into visual space using polar/spherical coordinat3es</span>
        <span class="n">polar_visual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">cylindrical_to_visual_polar</span><span class="p">(</span><span class="n">rho_z_phi</span><span class="p">)</span> <span class="k">for</span> <span class="n">rho_z_phi</span> <span class="ow">in</span> <span class="n">mesh_points_cylindrical</span><span class="p">])</span>
        <span class="c1"># convert to cartesian coordinates for visual space</span>
        <span class="n">cartesian_visual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">polar_visual</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">polar_visual</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">polar_visual</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">polar_visual</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]],</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cartesian_visual</span><span class="p">,</span> <span class="n">polar_visual</span></div>
</div>



<div class="viewcode-block" id="vis_cartesian_to_cortical_cartesian_coords">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.vis_cartesian_to_cortical_cartesian_coords">[docs]</a>
<span class="nd">@add_to_all</span><span class="p">(</span><span class="n">__all__</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vis_cartesian_to_cortical_cartesian_coords</span><span class="p">(</span><span class="n">cartesian_coords</span><span class="p">,</span> <span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">as_tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    * Map visual cartesian coordinates to 3d cortical cartesian coordinates using the 3D cortical model. </span>
<span class="sd">    * We use this when coordinates are sampled elsewhere, and we want to map them into the 3d model for receptive field sampling.</span>
<span class="sd">    * This is the main function we use to implement the cortical sensor manifold, in combination with isotropically magnified visual field sampling </span>
<span class="sd">    </span>
<span class="sd">    Note, the CMF is :math:`M(r)=\frac{k}{r+a}`</span>

<span class="sd">    Args:</span>
<span class="sd">        cartesian_coords (np.ndarray): (n,2) visual cartesian coordinates in (x,y) format</span>
<span class="sd">        cmf_a (float): :math:`a` value in the CMF, in degrees</span>
<span class="sd">        fov (float): field-of-view in degrees</span>
<span class="sd">        as_tensor (bool, optional): whether to return as a tensor. Defaults to False.</span>
<span class="sd">        device (str or torch.Device, optional): if as_tensor=True, which device to use</span>
<span class="sd">        k (float, optional): scaling value for CMF</span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray or torch.Tensor: (n, 3) array of cortical cartesian points :math:`(x_c, y_c, z)`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cartesian_fov_coords</span> <span class="o">=</span> <span class="n">cartesian_coords</span><span class="o">*</span><span class="p">(</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CorticalSensorManifold</span><span class="p">(</span><span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="n">grid_pts_3d</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">vis_cartesian_to_cort_cartesian</span><span class="p">(</span><span class="n">cartesian_fov_coords</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">as_tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">grid_pts_3d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid_pts_3d</span></div>



<div class="viewcode-block" id="vis_cartesian_to_cortical_cylindrical">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.vis_cartesian_to_cortical_cylindrical">[docs]</a>
<span class="nd">@add_to_all</span><span class="p">(</span><span class="n">__all__</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vis_cartesian_to_cortical_cylindrical</span><span class="p">(</span><span class="n">cartesian_coords</span><span class="p">,</span> <span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">as_tensor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map visual cartesian coordinates to cortical cylindrical coordinates using the 3D cortical model. </span>

<span class="sd">    * This is not usually used, since the cortical cartesian coordinates are more useful typically</span>
<span class="sd">    * We use this when coordinates are sampled elsewhere, and we want to map them into the 3D model for receptive field sampling.</span>

<span class="sd">    Note, the CMF is :math:`M(r)=\frac{k}{r+a}`</span>

<span class="sd">    Args:</span>
<span class="sd">        cartesian_coords (np.ndarray): (n,2) visual cartesian coordinates in (x,y) format</span>
<span class="sd">        cmf_a (float): :math:`a` value in the CMF, in degrees</span>
<span class="sd">        fov (float): field-of-view in degrees</span>
<span class="sd">        as_tensor (bool, optional): whether to return as a tensor. Defaults to False.</span>
<span class="sd">        device (str or torch.Device, optional): if as_tensor=True, which device to use</span>
<span class="sd">        k (float, optional): scaling value for CMF</span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray or torch.Tensor: (n, 3) array of cortical cylindrical points :math:`(\rho, z, \phi)`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cartesian_fov_coords</span> <span class="o">=</span> <span class="n">cartesian_coords</span><span class="o">*</span><span class="p">(</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CorticalSensorManifold</span><span class="p">(</span><span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="n">grid_pts_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">model</span><span class="o">.</span><span class="n">map_3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">cartesian_fov_coords</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">as_tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">grid_pts_3d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">grid_pts_3d</span></div>



<div class="viewcode-block" id="cortical_cylindrical_to_cortical_cartesian">
<a class="viewcode-back" href="../../../api/foveation.sensing.manifold.html#foveation.sensing.manifold.cortical_cylindrical_to_cortical_cartesian">[docs]</a>
<span class="nd">@add_to_all</span><span class="p">(</span><span class="n">__all__</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">cortical_cylindrical_to_cortical_cartesian</span><span class="p">(</span><span class="n">rho_z_phi</span><span class="p">,</span> <span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    map cortical cylindrical coordinates to cortical cartesian coordinates</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        rho_z_phi (np.ndarray): (n, 3) array of cortical cylindrical points :math:`(\rho, z, \phi)`</span>
<span class="sd">        cmf_a (float): :math:`a` value in CMF</span>
<span class="sd">        fov (float): field-of-view in degrees</span>
<span class="sd">        k (float, optional): scaling value for CMF</span>
<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: (n,3) array of cortical cartesian coordinates :math:`(x_c, y_c, z)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CorticalSensorManifold</span><span class="p">(</span><span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="n">grid_pts_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">model</span><span class="o">.</span><span class="n">map_to_xyz</span><span class="p">(</span><span class="n">rho_z_phi_i</span><span class="p">))</span> <span class="k">for</span> <span class="n">rho_z_phi_i</span> <span class="ow">in</span> <span class="n">rho_z_phi</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">grid_pts_3d</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">sample_coords_from_manifold</span><span class="p">(</span><span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">,</span> <span class="n">num_coords</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get sensor manifold coordinates using a 3D cortical model. </span>
<span class="sd">    </span>
<span class="sd">    * This samples the manifold approximately uniformly, but in practice it is not uniform enough. </span>
<span class="sd">    * Instead of using this, we typically:</span>

<span class="sd">        * sample isotropically in visual space (see .coords.SamplingCoords), then map into the 3d model for receptive field sampling. (vis_cartesian_to_cortical_cartesian_coords)</span>
<span class="sd">        * this leads to uniformly spaced points on the cortical manifold</span>
<span class="sd">        * thus, it is an indirect approach for even sampling on the manifold</span>
<span class="sd">        * it works much better than the direct method thus far implemented</span>

<span class="sd">    Args:</span>
<span class="sd">        cmf_a (float): a value in CMF</span>
<span class="sd">        fov (float): field-of-view in degrees</span>
<span class="sd">        num_coords (int, optional): number of points to sample</span>
<span class="sd">        device (str or torch.device, optional): which device to use</span>
<span class="sd">    Returns:</span>
<span class="sd">        result (tuple): A tuple containing:</span>
<span class="sd">            - coords (torch.Tensor): (n, 2) visual cartesian coordinates</span>
<span class="sd">            - polar_coords (torch.Tensor): (n, 2) visual polar coordinates</span>
<span class="sd">            - cortical_coords (torch.Tensor): (n, 3) cortical cartesian coordinates</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">CorticalSensorManifold</span><span class="p">(</span><span class="n">cmf_a</span><span class="p">,</span> <span class="n">fov</span><span class="p">)</span>
    <span class="c1"># define a grid of visual points to specify the bounds of the 3d mesh</span>
    <span class="n">grid_pts_3d_xyz</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">init_visual_mesh</span><span class="p">()</span>
    <span class="c1"># sample the mesh evenly</span>
    <span class="n">coords_3d</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">init_cortical_mesh</span><span class="p">(</span><span class="n">grid_pts_3d_xyz</span><span class="p">,</span> <span class="n">num_coords</span><span class="p">)</span>
    <span class="c1"># reverse map into visual space using polar/spherical coordinat3es</span>
    <span class="n">coords</span><span class="p">,</span> <span class="n">polar_coords</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">reverse_map</span><span class="p">(</span><span class="n">coords_3d</span><span class="p">)</span>
    <span class="c1"># get logz coordinates for plotting in 2D</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">normalize_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># flip x and y</span>
    <span class="n">polar_coords</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">polar_coords</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># divide radius by fov/2 to get it into the range [0,1]</span>
    <span class="n">polar_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">polar_coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">fov</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">cortical_coords</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">coords_3d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coords</span><span class="p">,</span> <span class="n">polar_coords</span><span class="p">,</span> <span class="n">cortical_coords</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>